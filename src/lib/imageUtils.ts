import { getApiUrl } from "@/config/env";

/**
 * Construye la URL completa de una imagen
 * @param imageUrl - URL de la imagen (puede ser relativa o absoluta)
 * @returns URL completa decodificada
 */
export const getImageUrl = (imageUrl: string): string => {
  if (!imageUrl) return '';
  
  // Si ya es una URL completa (Azure Blob Storage), decodificarla y retornarla
  if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
    return decodeURIComponent(imageUrl);
  }
  
  // Si es una ruta relativa, construir la URL con el backend
  const baseUrl = getApiUrl();
  const cleanFileName = imageUrl.startsWith('/') ? imageUrl.substring(1) : imageUrl;
  return `${baseUrl}/${cleanFileName}`;
};

/**
 * Extrae el nombre del archivo de una URL o path de imagen
 * @param imageUrl - URL o path de la imagen
 * @returns Nombre del archivo (ej: "abc-123-def.png")
 */
export const extractFileName = (imageUrl: string): string => {
  if (!imageUrl) return '';
  
  try {
    // Si es una URL completa, extraer el nombre del archivo de la URL
    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
      const url = new URL(decodeURIComponent(imageUrl));
      const pathname = url.pathname;
      // Obtener el último segmento de la ruta (el nombre del archivo)
      const segments = pathname.split('/').filter(segment => segment.length > 0);
      return segments[segments.length - 1] || '';
    }
    
    // Si es una ruta relativa (ej: "uploads/abc-123.png" o "/uploads/abc-123.png")
    const cleanPath = imageUrl.startsWith('/') ? imageUrl.substring(1) : imageUrl;
    const segments = cleanPath.split('/').filter(segment => segment.length > 0);
    return segments[segments.length - 1] || cleanPath;
  } catch (error) {
    // Si falla el parsing, intentar obtener el último segmento después del último "/"
    const lastSlashIndex = imageUrl.lastIndexOf('/');
    return lastSlashIndex >= 0 ? imageUrl.substring(lastSlashIndex + 1) : imageUrl;
  }
};

/**
 * Crea un archivo File dummy con el nombre especificado
 * El backend usa el nombre del archivo para identificar imágenes existentes
 * Crea una imagen mínima válida (1x1 pixel) para pasar la validación del backend
 * @param fileName - Nombre del archivo (ej: "abc-123-def.png")
 * @returns File object con el nombre especificado y contenido de imagen válido
 */
export const createDummyFile = (fileName: string): File => {
  const extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();
  let mimeType = 'image/png';
  let imageBytes: Uint8Array;
  
  // Crear imagen mínima válida según la extensión
  if (extension === 'jpg' || extension === 'jpeg') {
    mimeType = 'image/jpeg';
    // JPEG mínimo válido (1x1 pixel)
    // Firma: FFD8FF + datos mínimos válidos
    imageBytes = new Uint8Array([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00,
      0x80, 0xFF, 0xD9
    ]);
  } else if (extension === 'webp') {
    mimeType = 'image/webp';
    // WEBP mínimo válido (1x1 pixel)
    // Firma: 52494646 (RIFF)
    imageBytes = new Uint8Array([
      0x52, 0x49, 0x46, 0x46, 0x26, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
      0x56, 0x50, 0x38, 0x20, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);
  } else {
    // PNG por defecto - PNG mínimo válido (1x1 pixel transparente)
    // Firma: 89504E47
    imageBytes = new Uint8Array([
      0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
      0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
      0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
      0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
      0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49,
      0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
    ]);
  }
  
  // Crear blob con los bytes de la imagen mínima (convertir Uint8Array a array)
  const blob = new Blob([new Uint8Array(imageBytes)], { type: mimeType });
  
  // Crear un File con el nombre correcto
  return new File([blob], fileName, { type: mimeType });
};